project system/vold/
diff --git a/Android.mk b/Android.mk
index b7a4905..29a2453 100644
--- a/Android.mk
+++ b/Android.mk
@@ -16,7 +16,9 @@ common_src_files := \
 	Devmapper.cpp \
 	ResponseCode.cpp \
 	Xwarp.cpp \
-	cryptfs.c
+  cryptfs.c \
+  Exfat.cpp \
+  Ntfs.cpp
 
 common_c_includes := \
 	$(KERNEL_HEADERS) \
diff --git a/DirectVolume.cpp b/DirectVolume.cpp
index 2a24376..65d7137 100644
--- a/DirectVolume.cpp
+++ b/DirectVolume.cpp
@@ -45,6 +45,7 @@ DirectVolume::DirectVolume(VolumeManager *vm, const char *label,
     mDiskMajor = -1;
     mDiskMinor = -1;
     mDiskNumParts = 0;
+    mPartsEventCnt = 0;
 
     setState(Volume::State_NoMedia);
 }
@@ -157,6 +158,8 @@ void DirectVolume::handleDiskAdded(const char *devpath, NetlinkEvent *evt) {
         SLOGW("Kernel block uevent missing 'NPARTS'");
         mDiskNumParts = 1;
     }
+    
+     mPartsEventCnt = 0;
 
     int partmask = 0;
     int i;
@@ -186,6 +189,14 @@ void DirectVolume::handlePartitionAdded(const char *devpath, NetlinkEvent *evt)
     int part_num;
 
     const char *tmp = evt->findParam("PARTN");
+    
+    if(mPartsEventCnt > mDiskNumParts){
+        SLOGW("Partition event is to much, mPartsEventCnt=%d, mDiskNumParts=%d\n", mPartsEventCnt, mDiskNumParts);
+        mPartsEventCnt = mDiskNumParts;
+    }else{
+        mPartsEventCnt++;
+    }
+
 
     if (tmp) {
         part_num = atoi(tmp);
@@ -215,7 +226,8 @@ void DirectVolume::handlePartitionAdded(const char *devpath, NetlinkEvent *evt)
     } else {
         mPartMinors[part_num -1] = minor;
     }
-    mPendingPartMap &= ~(1 << part_num);
+   // mPendingPartMap &= ~(1 << part_num);
+   mPendingPartMap &= ~(1 << mPartsEventCnt);
 
     if (!mPendingPartMap) {
 #ifdef PARTITION_DEBUG
@@ -251,6 +263,8 @@ void DirectVolume::handleDiskChanged(const char *devpath, NetlinkEvent *evt) {
         SLOGW("Kernel block uevent missing 'NPARTS'");
         mDiskNumParts = 1;
     }
+    
+    mPartsEventCnt = 0;
 
     int partmask = 0;
     int i;
@@ -289,6 +303,10 @@ void DirectVolume::handleDiskRemoved(const char *devpath, NetlinkEvent *evt) {
              getLabel(), getMountpoint(), major, minor);
     mVm->getBroadcaster()->sendBroadcast(ResponseCode::VolumeDiskRemoved,
                                              msg, false);
+                                             
+    /* 2011-4-30 force unmount fs */
+    SLOGD("DirectVolume : handleDiskRemoved : unmountVol");
+    Volume::unmountVol(true,true);
     setState(Volume::State_NoMedia);
 }
 
@@ -316,11 +334,12 @@ void DirectVolume::handlePartitionRemoved(const char *devpath, NetlinkEvent *evt
          * Yikes, our mounted partition is going away!
          */
 
+        if(!strstr(getLabel(),"usb")&&!strstr(getLabel(),"extsd")){
         snprintf(msg, sizeof(msg), "Volume %s %s bad removal (%d:%d)",
                  getLabel(), getMountpoint(), major, minor);
         mVm->getBroadcaster()->sendBroadcast(ResponseCode::VolumeBadRemoval,
                                              msg, false);
-
+		}		       
 	if (mVm->cleanupAsec(this, true)) {
             SLOGE("Failed to cleanup ASEC - unmount will probably fail!");
         }
@@ -354,20 +373,21 @@ void DirectVolume::handlePartitionRemoved(const char *devpath, NetlinkEvent *evt
 int DirectVolume::getDeviceNodes(dev_t *devs, int max) {
 
     if (mPartIdx == -1) {
-        // If the disk has no partitions, try the disk itself
-        if (!mDiskNumParts) {
-            devs[0] = MKDEV(mDiskMajor, mDiskMinor);
-            return 1;
-        }
+		// If the disk has no partitions, try the disk itself
+		if (!mDiskNumParts) {
+		    devs[0] = MKDEV(mDiskMajor, mDiskMinor);
+		    return 1;
+		}
+
+		int i;
+		for (i = 0; i < mDiskNumParts; i++) {
+		    if (i == max)
+		        break;
+		    devs[i] = MKDEV(mDiskMajor, mPartMinors[i]);
+		}
+		return mDiskNumParts;
+	 }
 
-        int i;
-        for (i = 0; i < mDiskNumParts; i++) {
-            if (i == max)
-                break;
-            devs[i] = MKDEV(mDiskMajor, mPartMinors[i]);
-        }
-        return mDiskNumParts;
-    }
     devs[0] = MKDEV(mDiskMajor, mPartMinors[mPartIdx -1]);
     return 1;
 }
diff --git a/DirectVolume.h b/DirectVolume.h
index de1ed8b..76f0eee 100644
--- a/DirectVolume.h
+++ b/DirectVolume.h
@@ -21,13 +21,13 @@
 
 #include "Volume.h"
 
-#define MAX_PARTS 4
+#define MAX_PARTS 16
 
 typedef android::List<char *> PathCollection;
 
 class DirectVolume : public Volume {
 public:
-    static const int MAX_PARTITIONS = 4;
+    static const int MAX_PARTITIONS = 16;
 protected:
     PathCollection *mPaths;
     int            mDiskMajor;
@@ -37,6 +37,7 @@ protected:
     int            mOrigDiskMinor;
     int            mOrigPartMinors[MAX_PARTITIONS];
     int            mDiskNumParts;
+    int            mPartsEventCnt;
     unsigned char  mPendingPartMap;
     int            mIsDecrypted;
     int            mFlags;
diff --git a/Fat.cpp b/Fat.cpp
index 82a3f7a..b82f9b2 100644
--- a/Fat.cpp
+++ b/Fat.cpp
@@ -58,11 +58,10 @@ int Fat::check(const char *fsPath) {
         const char *args[5];
         args[0] = FSCK_MSDOS_PATH;
         args[1] = "-p";
-        args[2] = "-f";
-        args[3] = fsPath;
-        args[4] = NULL;
+        args[2] = fsPath;
+        args[3] = NULL;
 
-        rc = logwrap(4, args, 1);
+        rc = logwrap(3, args, 1);
 
         switch(rc) {
         case 0:
@@ -151,9 +150,13 @@ int Fat::doMount(const char *fsPath, const char *mountPoint,
     return rc;
 }
 
-int Fat::format(const char *fsPath, unsigned int numSectors) {
+int Fat::format(const char *fsPath, unsigned int numSectors){
+       return Fat::format(fsPath, numSectors, NULL);
+}
+
+int Fat::format(const char *fsPath, unsigned int numSectors, const char *lable) {
     int fd;
-    const char *args[11];
+    const char *args[13];
     int rc;
 
     args[0] = MKDOSFS_PATH;
@@ -169,14 +172,31 @@ int Fat::format(const char *fsPath, unsigned int numSectors) {
         snprintf(tmp, sizeof(tmp), "%u", numSectors);
         const char *size = tmp;
         args[7] = "-s";
-        args[8] = size;
-        args[9] = fsPath;
-        args[10] = NULL;
-        rc = logwrap(11, args, 1);
-    } else {
-        args[7] = fsPath;
-        args[8] = NULL;
-        rc = logwrap(9, args, 1);
+        args[8] = size;        
+        if( lable ){
+	           args[9] = "-L" ;
+	           args[10] = lable;
+	           args[11] = fsPath;                              
+	           args[12] = NULL;                
+	           rc = logwrap(13, args, 1);
+        }else{
+	           args[9] = fsPath;       
+	           args[10] = NULL;                        
+	           rc = logwrap(11, args, 1);      
+        }               
+        
+    } else {        
+        if( lable ) {
+	           args[7] = "-L" ;
+	           args[8] = lable;
+	           args[9] = fsPath;
+	           args[10] = NULL;                        
+	           rc = logwrap(11, args, 1);
+         }else{
+             args[7] = fsPath;
+             args[8] = NULL;                 
+             rc = logwrap(9, args, 1);       
+         }  
     }
 
     if (rc == 0) {
diff --git a/Fat.h b/Fat.h
index e02d88c..f3e4729 100644
--- a/Fat.h
+++ b/Fat.h
@@ -27,6 +27,7 @@ public:
                        int ownerUid, int ownerGid, int permMask,
                        bool createLost);
     static int format(const char *fsPath, unsigned int numSectors);
+    static int format(const char *fsPath, unsigned int numSectors, const char *lable);
 };
 
 #endif
diff --git a/Volume.cpp b/Volume.cpp
index 0be2e81..4f8a33c 100644
--- a/Volume.cpp
+++ b/Volume.cpp
@@ -44,9 +44,13 @@
 #include "VolumeManager.h"
 #include "ResponseCode.h"
 #include "Fat.h"
+#include "Ntfs.h"
+#include "Exfat.h"
 #include "Process.h"
 #include "cryptfs.h"
 
+#define  V_MAX_PARTITIONS              16
+
 extern "C" void dos_partition_dec(void const *pp, struct dos_partition *d);
 extern "C" void dos_partition_enc(void *pp, struct dos_partition *d);
 
@@ -114,13 +118,22 @@ static const char *stateToStr(int state) {
 
 Volume::Volume(VolumeManager *vm, const char *label, const char *mount_point) {
     mVm = vm;
-    mDebug = false;
+    mDebug = true;
     mLabel = strdup(label);
     mMountpoint = strdup(mount_point);
     mState = Volume::State_Init;
     mCurrentlyMountedKdev = -1;
     mPartIdx = -1;
     mRetryMount = false;
+
+    for(int i = 0; i < MAX_PARTITIONS; i++){
+   		 mMountPart[i] = NULL;
+       mSharelun[i] = 0;
+    }
+
+   	for(int i = 0; i < MAX_UNMOUNT_PARTITIONS; i++){
+  		 mUnMountPart[i] = NULL;
+   	}
 }
 
 Volume::~Volume() {
@@ -207,8 +220,150 @@ int Volume::createDeviceNode(const char *path, int major, int minor) {
     return 0;
 }
 
+/* path: partition mount path. eg: '/mnt/usbhost1/8_1' */
+int Volume::deleteDeviceNode(const char *path){
+#if 0
+    int major = 0, minor = 0;
+       char devicePath[255];
+
+       char *temp_str1 = NULL;
+       char *temp_str2 = NULL;
+       char str_major[256];
+       char str_path[256];
+       int len = 0;
+
+       if(!path){
+               SLOGE("Volume::deleteDeviceNode: path(%s) is invalid\n", path);
+               return -1;
+       }
+
+       SLOGI("Volume::deleteDeviceNode: path=%s\n", path);
+
+       /* get device major and minor from path */
+       memset(str_major, 0, 256);
+       memset(str_path, 0, 256);
+       strcpy(str_path, path);
+
+       temp_str1 = strrchr(str_path, '/');
+       temp_str2 = strrchr(str_path, '_');
+       if(temp_str1 == NULL || temp_str2 == NULL){
+               SLOGE("Volume::deleteDeviceNode: path(%s) is invalid\n", path);
+               return -1;
+       }
+
+       /* delete '/' & '_' */
+       temp_str1++;
+       temp_str2++;
+       if(temp_str1 == NULL || temp_str2 == NULL){
+               SLOGE("Volume::deleteDeviceNode: path(%s) is invalid\n", path);
+               return -1;
+       }
+
+       len = strcspn(temp_str1, "_");
+       strncpy(str_major, temp_str1, len);
+
+       major = strtol(str_major, NULL, 10);
+       minor = strtol(temp_str2, NULL, 10);
+
+       SLOGI("Volume::deleteDeviceNode: major=%d, minor=%d\n", major, minor);
+
+       /* delete DeviceNode */
+       memset(devicePath, 0, 255);
+       sprintf(devicePath, "/dev/block/vold/%d:%d", major, minor);
+
+       if (unlink(devicePath)) {
+               SLOGE("Volume::deleteDeviceNode: Failed to remove %s (%s)", path, strerror(errno));
+               return -1;
+       }else{
+               SLOGI("Volume::deleteDeviceNode: delete DeviceNode '%s' successful\n", path);
+       }
+
+#endif
+
+       return 0;
+}
+
+char* Volume::createMountPoint(const char *path, int major, int minor) {
+       char* mountpoint = (char*) malloc(sizeof(char)*256);
+
+       memset(mountpoint, 0, sizeof(char)*256);
+       sprintf(mountpoint, "%s/%d_%d", path, major, minor);
+
+       if( access(mountpoint, F_OK) ){
+               SLOGI("Volume: file '%s' is not exist, create it", mountpoint);
+
+               if(mkdir(mountpoint, 0777)){
+                       SLOGW("Volume: create file '%s' failed, errno is %d", mountpoint, errno);
+                       return NULL;
+               }
+       }else{
+               /* ��?��?��?��?��?��??����???1��??��?��??a��?��?��??1D����a��?��1��???? */
+               SLOGW("Volume: file '%s' is exist, can not create it", mountpoint);
+               return mountpoint;
+       }
+
+       return mountpoint;
+}
+
+int Volume::deleteMountPoint(char* mountpoint) {
+       if(mountpoint){
+               if( !access(mountpoint, F_OK) ){
+                       SLOGW("Volume::deleteMountPoint: %s", mountpoint);
+                       if(rmdir(mountpoint)){
+                               SLOGW("Volume: remove file '%s' failed, errno is %d", mountpoint, errno);
+                               return -1;
+                       }
+               }
+
+               /* ?T??��?��?��?3y3��1|��??a��???������??����? */
+               free(mountpoint);
+               mountpoint = NULL;
+       }
+
+       return 0;
+}
+
+void Volume::saveUnmountPoint(char* mountpoint){
+       int i = 0;
+
+       for(i = 0; i < MAX_UNMOUNT_PARTITIONS; i++){
+               if(mUnMountPart[i] == NULL){
+                       mUnMountPart[i] = mMountPart[i];
+               }
+       }
+
+       if(i >= MAX_UNMOUNT_PARTITIONS){
+               SLOGI("Volume::saveUnmountPoint: unmount point is over %d", MAX_UNMOUNT_PARTITIONS);
+       }
+
+       return;
+}
+
+/* ��?3y?����D1��?????? */
+void Volume::deleteUnMountPoint(int clear){
+       int i = 0;
+
+       for(i = 0; i < MAX_UNMOUNT_PARTITIONS; i++){
+               if(mUnMountPart[i]){
+                       SLOGW("Volume::deleteUnMountPoint: %s", mUnMountPart[i]);
+
+                       if(deleteMountPoint(mUnMountPart[i]) == 0){
+                               deleteDeviceNode(mUnMountPart[i]);
+                               mUnMountPart[i] = NULL;
+                       }
+               }
+       }
+
+       return;
+}
+
+
+
+
 int Volume::formatVol() {
 
+	  char lable[32];
+
     if (getState() == Volume::State_NoMedia) {
         errno = ENODEV;
         return -1;
@@ -234,24 +389,15 @@ int Volume::formatVol() {
 
     int ret = -1;
     // Only initialize the MBR if we are formatting the entire device
-    if (formatEntireDevice) {
-        sprintf(devicePath, "/dev/block/vold/%d:%d",
-                MAJOR(diskNode), MINOR(diskNode));
-
-        if (initializeMbr(devicePath)) {
-            SLOGE("Failed to initialize MBR (%s)", strerror(errno));
-            goto err;
-        }
-    }
-
-    sprintf(devicePath, "/dev/block/vold/%d:%d",
-            MAJOR(partNode), MINOR(partNode));
+    getDeviceNodes(&partNode, 1);
+    sprintf(devicePath, "/dev/block/vold/%d:%d",MAJOR(partNode), MINOR(partNode));
 
     if (mDebug) {
         SLOGI("Formatting volume %s (%s)", getLabel(), devicePath);
     }
 
-    if (Fat::format(devicePath, 0)) {
+    property_get("ro.udisk.lable", lable, "udisk");
+    if (Fat::format(devicePath, 0,lable)) {
         SLOGE("Failed to format (%s)", strerror(errno));
         goto err;
     }
@@ -290,8 +436,9 @@ bool Volume::isMountpointMounted(const char *path) {
 }
 
 int Volume::mountVol() {
-    dev_t deviceNodes[4];
+    dev_t deviceNodes[V_MAX_PARTITIONS];
     int n, i, rc = 0;
+    int mounted = 0;
     char errmsg[255];
     const char* externalStorage = getenv("EXTERNAL_STORAGE");
     bool primaryStorage = externalStorage && !strcmp(getMountpoint(), externalStorage);
@@ -306,6 +453,7 @@ int Volume::mountVol() {
     /* Don't try to mount the volumes if we have not yet entered the disk password
      * or are in the process of encrypting.
      */
+    SLOGI("Volume::mountVol state : %d", getState());
     if ((getState() == Volume::State_NoMedia) ||
         ((!strcmp(decrypt_state, "1") || encrypt_progress[0]) && primaryStorage)) {
         snprintf(errmsg, sizeof(errmsg),
@@ -321,6 +469,9 @@ int Volume::mountVol() {
         if (getState() == Volume::State_Pending) {
             mRetryMount = true;
         }
+        
+        SLOGW("Volume::mountVol: Volume mState is not State_Idle");
+        
         return -1;
     }
 
@@ -331,7 +482,7 @@ int Volume::mountVol() {
         return 0;
     }
 
-    n = getDeviceNodes((dev_t *) &deviceNodes, 4);
+    n = getDeviceNodes((dev_t *) &deviceNodes, V_MAX_PARTITIONS);
     if (!n) {
         SLOGE("Failed to get device nodes (%s)\n", strerror(errno));
         return -1;
@@ -380,16 +531,27 @@ int Volume::mountVol() {
         updateDeviceInfo(nodepath, new_major, new_minor);
 
         /* Get the device nodes again, because they just changed */
-        n = getDeviceNodes((dev_t *) &deviceNodes, 4);
+        n = getDeviceNodes((dev_t *) &deviceNodes, V_MAX_PARTITIONS);
         if (!n) {
             SLOGE("Failed to get device nodes (%s)\n", strerror(errno));
             return -1;
         }
     }
+    
+    SLOGI("Volume::mountVol: mMountpoint %s\n", mMountpoint);
+
+		/* ����??1��??��?��?����?T */
+		if(((mPartIdx == -1) &&(n > 1)) && mMountpoint){
+		       chmod(mMountpoint, 0x777);
+		
+		       /* ��?3y��?��?��?2D��?��??����???1��??��? */
+		       deleteUnMountPoint(1);
+		}
 
     for (i = 0; i < n; i++) {
         char devicePath[255];
 
+				memset(devicePath, 0, 255);
         sprintf(devicePath, "/dev/block/vold/%d:%d", MAJOR(deviceNodes[i]),
                 MINOR(deviceNodes[i]));
 
@@ -398,6 +560,7 @@ int Volume::mountVol() {
         errno = 0;
         setState(Volume::State_Checking);
 
+#if 0
         if (Fat::check(devicePath)) {
             if (errno == ENODATA) {
                 SLOGW("%s does not contain a FAT filesystem\n", devicePath);
@@ -409,6 +572,7 @@ int Volume::mountVol() {
             setState(Volume::State_Idle);
             return -1;
         }
+#endif
 
         /*
          * Mount the device on our internal staging mountpoint so we can
@@ -425,11 +589,42 @@ int Volume::mountVol() {
             // For secondary external storage we keep things locked up.
             gid = AID_MEDIA_RW;
         }
+        
+        if( !Exfat::check(devicePath) )
+        {
+             if( Exfat::doMount(devicePath, "/mnt/secure/staging", false, false, false, AID_SYSTEM, gid, 0702, true) )
+             {
+                SLOGE("%s failed to mount via ExFat (%s)\n", devicePath, strerror(errno));
+             }
+        }
+        else if( !Fat::check(devicePath))
+        {
+             if( Fat::doMount(devicePath, "/mnt/secure/staging", false, false, false, AID_SYSTEM, gid, 0702, true) )
+             {
+                     SLOGE("%s failed to mount via VFAT (%s)\n", devicePath, strerror(errno));
+             }
+        }
+        else if( !Ntfs::check(devicePath))
+        {
+             if( Ntfs::doMount(devicePath, "/mnt/secure/staging", false, false, false, AID_SYSTEM, gid, 0702, true) )
+             {
+                     SLOGE("%s failed to mount via NTFS (%s)\n", devicePath, strerror(errno));
+             }
+        }
+        else
+        {
+            SLOGE("%s failed FS checks (%s)", devicePath, strerror(errno));
+            setState(Volume::State_Idle);
+            continue;
+        }        
+        
+#if 0
         if (Fat::doMount(devicePath, "/mnt/secure/staging", false, false, false,
                 AID_SYSTEM, gid, 0702, true)) {
             SLOGE("%s failed to mount via VFAT (%s)\n", devicePath, strerror(errno));
             continue;
         }
+#endif
 
         SLOGI("Device %s, target %s mounted @ /mnt/secure/staging", devicePath, getMountpoint());
 
@@ -447,6 +642,7 @@ int Volume::mountVol() {
          * Now that the bindmount trickery is done, atomically move the
          * whole subtree to expose it to non priviledged users.
          */
+#if 0
         if (doMoveMount("/mnt/secure/staging", getMountpoint(), false)) {
             SLOGE("Failed to move mount (%s)", strerror(errno));
             umount("/mnt/secure/staging");
@@ -456,10 +652,66 @@ int Volume::mountVol() {
         setState(Volume::State_Mounted);
         mCurrentlyMountedKdev = deviceNodes[i];
         return 0;
-    }
-
+#else
+	       /* auto mount and much partition */
+	     if((mPartIdx == -1) && (n > 1)){
+           mMountPart[i] = createMountPoint( mMountpoint, MAJOR(deviceNodes[i]), MINOR(deviceNodes[i]) );
+           if(mMountPart[i] == NULL){
+                   SLOGE("Part is already mount, can not mount again, (%s)\n", strerror(errno));
+                   umount("/mnt/secure/staging");
+                   continue;
+           }
+	
+           if (doMoveMount("/mnt/secure/staging", mMountPart[i], false)) {
+		   				SLOGE("wangjx 13-----------");
+                   SLOGE("Part(%s) failed to move mount (%s)\n", mMountPart[i], strerror(errno));
+                   deleteMountPoint(mMountPart[i]);
+                   mMountPart[i] = NULL;
+                   umount("/mnt/secure/staging");
+                   continue;
+           }
+
+           SLOGI("mountVlo: mount %s, successful\n", mMountPart[i]);
+
+           mCurrentlyMountedKdev = deviceNodes[i];
+           mounted++;
+	     }else{
+	        if (doMoveMount("/mnt/secure/staging", getMountpoint(), false)) {
+				 	 SLOGE("wangjx------------\n");
+				     SLOGE("Failed to move mount (%s)\n", strerror(errno));
+				     umount("/mnt/secure/staging");
+				     goto failed;
+	     		}
+	
+		      setState(Volume::State_Mounted);
+		      mCurrentlyMountedKdev = deviceNodes[i];
+		      mMountedPartNum = 1;
+		
+		     	return 0;
+	     }
+#endif
+	}
+	
+   mMountedPartNum = n;
+	 if(mounted){
+	     setState(Volume::State_Mounted);
+	 }else{
+	         SLOGE("mount part failed\n");
+	
+	         mMountedPartNum = 0;
+	         setState(Volume::State_Idle);
+	
+	         goto failed;
+	 }
+
+   SLOGI("Volume::mountVol: getState=%d, State_Mounted=%d\n", getState(), Volume::State_Mounted);
+
+   return 0;
+
+failed:
     SLOGE("Volume %s found no suitable devices for mounting :(\n", getLabel());
     setState(Volume::State_Idle);
+    mCurrentlyMountedKdev = -1;
 
     return -1;
 }
@@ -530,15 +782,17 @@ int Volume::createBindMounts() {
 int Volume::doMoveMount(const char *src, const char *dst, bool force) {
     unsigned int flags = MS_MOVE;
     int retries = 5;
-
+	int ret = 0; 
+	
     while(retries--) {
-        if (!mount(src, dst, "", flags, NULL)) {
+		 ret = mount(src, dst, "", flags, NULL);
+        if (!ret) {
             if (mDebug) {
                 SLOGD("Moved mount %s -> %s sucessfully", src, dst);
             }
             return 0;
         } else if (errno != EBUSY) {
-            SLOGE("Failed to move mount %s -> %s (%s)", src, dst, strerror(errno));
+            SLOGE("Warning to move mount %s -> %s (%s)", src, dst, strerror(errno));
             return -1;
         }
         int action = 0;
@@ -569,7 +823,7 @@ int Volume::doUnmount(const char *path, bool force) {
     }
 
     while (retries--) {
-        if (!umount(path) || errno == EINVAL || errno == ENOENT) {
+        if (!umount(path) || errno == EINVAL || errno == ENOENT || errno == ENOTCONN) {
             SLOGI("%s sucessfully unmounted", path);
             return 0;
         }
@@ -607,33 +861,54 @@ int Volume::unmountVol(bool force, bool revert) {
     setState(Volume::State_Unmounting);
     usleep(1000 * 1000); // Give the framework some time to react
 
-    /*
-     * Remove the bindmount we were using to keep a reference to
-     * the previously obscured directory.
-     */
-    if (doUnmount(Volume::SEC_ASECDIR_EXT, force)) {
-        SLOGE("Failed to remove bindmount on %s (%s)", SEC_ASECDIR_EXT, strerror(errno));
-        goto fail_remount_tmpfs;
-    }
+    if(getMountpoint()!=NULL&&!strstr(getMountpoint(),"usb")&&!strstr(getMountpoint(),"extsd")){
+        /*
+         * Remove the bindmount we were using to keep a reference to
+         * the previously obscured directory.
+         */
+        if (doUnmount(Volume::SEC_ASECDIR_EXT, force)) {
+            SLOGE("Failed to remove bindmount on %s (%s)", SEC_ASECDIR_EXT, strerror(errno));
+            goto fail_remount_tmpfs;
+        }
 
-    /*
-     * Unmount the tmpfs which was obscuring the asec image directory
-     * from non root users
-     */
-    char secure_dir[PATH_MAX];
-    snprintf(secure_dir, PATH_MAX, "%s/.android_secure", getMountpoint());
-    if (doUnmount(secure_dir, force)) {
-        SLOGE("Failed to unmount tmpfs on %s (%s)", secure_dir, strerror(errno));
-        goto fail_republish;
+        /*
+         * Unmount the tmpfs which was obscuring the asec image directory
+         * from non root users
+         */
+        char secure_dir[PATH_MAX];
+        snprintf(secure_dir, PATH_MAX, "%s/.android_secure", getMountpoint());
+        if (doUnmount(secure_dir, force)) {
+            SLOGE("Failed to unmount tmpfs on %s (%s)", secure_dir, strerror(errno));
+            goto fail_republish;
+        }
+    }
+    SLOGE("mPartIdx = %d, mMountedPartNum = %d\n",mPartIdx,mMountedPartNum);
+    for(i=0;i<mMountedPartNum;i++)
+    {
+    	if(mPartIdx==-1&&mMountedPartNum>1){
+    		if(mMountPart[i]){
+    			if (doUnmount(mMountPart[i], force)) {
+    			        SLOGE("Failed to unmount %s (%s)", SEC_STGDIR, strerror(errno));
+    			        goto fail_recreate_bindmount;
+    			 }
+                if(deleteMountPoint(mMountPart[i])){
+                        saveUnmountPoint(mMountPart[i]);
+                }else{
+                        deleteDeviceNode(mMountPart[i]);
+                }
+                mMountPart[i] = NULL;
+    		}
+    	}else{
+    		if (doUnmount(getMountpoint(), force)) {
+    			        SLOGE("Failed to unmount %s (%s)", SEC_STGDIR, strerror(errno));
+    			        goto fail_recreate_bindmount;
+    		}
+    	}
     }
-
     /*
      * Finally, unmount the actual block device from the staging dir
      */
-    if (doUnmount(getMountpoint(), force)) {
-        SLOGE("Failed to unmount %s (%s)", SEC_STGDIR, strerror(errno));
-        goto fail_recreate_bindmount;
-    }
+
 
     SLOGI("%s unmounted sucessfully", getMountpoint());
 
@@ -646,6 +921,10 @@ int Volume::unmountVol(bool force, bool revert) {
         revertDeviceInfo();
         SLOGI("Encrypted volume %s reverted successfully", getMountpoint());
     }
+		if(((mPartIdx == -1) &&(mMountedPartNum > 1)) && mMountpoint){
+		       deleteUnMountPoint(0);
+		       chmod(mMountpoint, 0x00);
+       }
 
     setState(Volume::State_Idle);
     mCurrentlyMountedKdev = -1;
@@ -677,6 +956,128 @@ out_nomedia:
     setState(Volume::State_NoMedia);
     return -1;
 }
+
+int Volume::shareVol(int lun) {
+       int n = 0, i = 0, share = 0;
+       dev_t deviceNodes[V_MAX_PARTITIONS];
+
+       SLOGW("Volume::shareVol, lun=%d", lun);
+
+       n = getDeviceNodes(deviceNodes, V_MAX_PARTITIONS);
+
+       for( i=0; i< n; i++ ) {
+               dev_t d = deviceNodes[i];
+               mSharelun[i] = lun + i;
+
+               if ((MAJOR(d) == 0) && (MINOR(d) == 0)) {
+                   // This volume does not support raw disk access
+                   errno = EINVAL;
+                   return 0;
+               }
+
+               int fd = -1;
+               char nodepath[255];
+               char umslun[255];
+
+               memset(nodepath, 0, 255);
+               memset(umslun, 0, 255);
+
+               snprintf(nodepath,
+                                sizeof(nodepath), "/dev/block/vold/%d:%d",
+                                MAJOR(d), MINOR(d));
+
+               if(mSharelun[i] == 0)
+                       snprintf(umslun, sizeof(umslun), "/sys/class/android_usb/android0/f_mass_storage/lun/file");
+               else
+                       snprintf(umslun, sizeof(umslun), "/sys/class/android_usb/android0/f_mass_storage/lun%d/file", mSharelun[i]);
+
+               SLOGI("shareVol: %s; umslun: %s", nodepath, umslun);
+
+               if ((fd = open(umslun,O_WRONLY)) < 0) {
+                   SLOGE("Unable to open ums lunfile (%s)", strerror(errno));
+                   return 0;
+               }
+
+               if (write(fd, nodepath, strlen(nodepath)) < 0) {
+                   SLOGE("Unable to write to ums lunfile (%s)", strerror(errno));
+                   close(fd);
+                   return 0;
+               }
+
+               close(fd);
+
+               handleVolumeShared();
+
+               share++;
+       }
+
+       SLOGI("shareVol: share = %d\n", share);
+
+    return share;
+}
+
+int Volume::unshareVol() {
+       int i,n;
+       dev_t deviceNodes[V_MAX_PARTITIONS];
+
+       SLOGW("Volume::unshareVol");
+
+       n = getDeviceNodes(deviceNodes, V_MAX_PARTITIONS);
+
+       for( i=0; i< n; i++) {
+               int fd;
+               char umslun[255];
+
+               memset(umslun, 0, 255);
+
+               if(mSharelun[i] == 0)
+                       snprintf(umslun, sizeof(umslun), "/sys/class/android_usb/android0/f_mass_storage/lun/file");
+               else
+                       snprintf(umslun, sizeof(umslun), "/sys/class/android_usb/android0/f_mass_storage/lun%d/file", mSharelun[i]);
+
+               SLOGI("unshareVol: umslun '%s'", umslun);
+
+               if ((fd = open(umslun, O_WRONLY)) < 0) {
+               SLOGE("Unable to open ums lunfile (%s), (%s)", umslun, strerror(errno));
+               return 0;
+           }
+
+       char ch = 0;
+#if 1
+               int wait_i = 0;
+
+               while(wait_i < 30){
+                       if (write(fd, &ch, 1) >= 0) {
+                               break;
+                       }
+
+                       SLOGE("---wait :%d %d \n", wait_i);
+                       wait_i++;
+                       usleep(100);
+               }
+
+               if(wait_i == 30){
+                       SLOGE("Unable to write to ums lunfile (%s)", strerror(errno));
+                       close(fd);
+                       return 0;
+               }
+#else
+               if (write(fd, &ch, 1) < 0) {
+                       SLOGE("Unable to write to ums lunfile (%s)", strerror(errno));
+                       close(fd);
+                       return -1;
+               }
+#endif
+
+               close(fd);
+
+               handleVolumeUnshared();
+       }
+
+    return n;
+}
+
+
 int Volume::initializeMbr(const char *deviceNode) {
     struct disk_info dinfo;
 
diff --git a/Volume.h b/Volume.h
index c717d4d..e5be072 100644
--- a/Volume.h
+++ b/Volume.h
@@ -46,10 +46,17 @@ public:
     static const char *ASECDIR;
 
     static const char *LOOPDIR;
+    static const int MAX_PARTITIONS = 16;
+    static const int MAX_UNMOUNT_PARTITIONS = 256;
 
 protected:
     char *mLabel;
     char *mMountpoint;
+    
+    char *mMountPart[MAX_PARTITIONS];           //1¨°??¦Ì?
+    char *mUnMountPart[MAX_UNMOUNT_PARTITIONS]; //?a¨¦?3y3¨¦1|¦Ì?1¨°??¦Ì?
+    int mSharelun[MAX_PARTITIONS];
+
     VolumeManager *mVm;
     bool mDebug;
     int mPartIdx;
@@ -68,6 +75,8 @@ public:
     int mountVol();
     int unmountVol(bool force, bool revert);
     int formatVol();
+    int shareVol(int lun);
+    int unshareVol();
 
     const char *getLabel() { return mLabel; }
     const char *getMountpoint() { return mMountpoint; }
@@ -92,6 +101,7 @@ protected:
     virtual int getFlags(void) = 0;
 
     int createDeviceNode(const char *path, int major, int minor);
+    int deleteDeviceNode(const char *path);
 
 private:
     int initializeMbr(const char *deviceNode);
@@ -100,6 +110,13 @@ private:
     int doUnmount(const char *path, bool force);
     int doMoveMount(const char *src, const char *dst, bool force);
     void protectFromAutorunStupidity();
+    
+    char* createMountPoint(const char *path, int major, int minor);
+    int deleteMountPoint(char* mountpoint);
+    void saveUnmountPoint(char* mountpoint);
+    void deleteUnMountPoint(int clear);
+
+    int mMountedPartNum; /* the partition numbers that had mounted */
 };
 
 typedef android::List<Volume *> VolumeCollection;
diff --git a/VolumeManager.cpp b/VolumeManager.cpp
index ca5ec84..968dd02 100644
--- a/VolumeManager.cpp
+++ b/VolumeManager.cpp
@@ -50,6 +50,7 @@
 #include "cryptfs.h"
 
 #define MASS_STORAGE_FILE_PATH  "/sys/class/android_usb/android0/f_mass_storage/lun/file"
+#define UMS_DIRTY_RATIO_DEFAULT  40
 
 VolumeManager *VolumeManager::sInstance = NULL;
 
@@ -67,8 +68,9 @@ VolumeManager::VolumeManager() {
     mUmsSharingCount = 0;
     mSavedDirtyRatio = -1;
     // set dirty ratio to 0 when UMS is active
-    mUmsDirtyRatio = 0;
+    mUmsDirtyRatio = UMS_DIRTY_RATIO_DEFAULT;  /* by javen */
     mVolManagerDisabled = 0;
+    mlun =0;
 }
 
 VolumeManager::~VolumeManager() {
@@ -1181,6 +1183,7 @@ int VolumeManager::shareEnabled(const char *label, const char *method, bool *ena
 
 int VolumeManager::shareVolume(const char *label, const char *method) {
     Volume *v = lookupVolume(label);
+    int part = 0;
 
     if (!v) {
         errno = ENOENT;
@@ -1220,31 +1223,17 @@ int VolumeManager::shareVolume(const char *label, const char *method) {
         return -1;
     }
 
-    int fd;
-    char nodepath[255];
-    snprintf(nodepath,
-             sizeof(nodepath), "/dev/block/vold/%d:%d",
-             MAJOR(d), MINOR(d));
-
-    if ((fd = open(MASS_STORAGE_FILE_PATH, O_WRONLY)) < 0) {
-        SLOGE("Unable to open ums lunfile (%s)", strerror(errno));
-        return -1;
-    }
+    part=v->shareVol(mlun);
+    mlun += part;
+    SLOGI("shareVolume: mlun = %d", mlun);
 
-    if (write(fd, nodepath, strlen(nodepath)) < 0) {
-        SLOGE("Unable to write to ums lunfile (%s)", strerror(errno));
-        close(fd);
-        return -1;
-    }
-
-    close(fd);
-    v->handleVolumeShared();
     if (mUmsSharingCount++ == 0) {
         FILE* fp;
         mSavedDirtyRatio = -1; // in case we fail
         if ((fp = fopen("/proc/sys/vm/dirty_ratio", "r+"))) {
             char line[16];
             if (fgets(line, sizeof(line), fp) && sscanf(line, "%d", &mSavedDirtyRatio)) {
+				mUmsDirtyRatio = UMS_DIRTY_RATIO_DEFAULT;
                 fprintf(fp, "%d\n", mUmsDirtyRatio);
             } else {
                 SLOGE("Failed to read dirty_ratio (%s)", strerror(errno));
@@ -1259,6 +1248,8 @@ int VolumeManager::shareVolume(const char *label, const char *method) {
 
 int VolumeManager::unshareVolume(const char *label, const char *method) {
     Volume *v = lookupVolume(label);
+    
+    int part = 0;
 
     if (!v) {
         errno = ENOENT;
@@ -1274,22 +1265,12 @@ int VolumeManager::unshareVolume(const char *label, const char *method) {
         errno = EINVAL;
         return -1;
     }
+    
+    part=v->unshareVol();
+    mlun -= part;
+       
+    SLOGI("unshareVolume: lun = %d", mlun);
 
-    int fd;
-    if ((fd = open(MASS_STORAGE_FILE_PATH, O_WRONLY)) < 0) {
-        SLOGE("Unable to open ums lunfile (%s)", strerror(errno));
-        return -1;
-    }
-
-    char ch = 0;
-    if (write(fd, &ch, 1) < 0) {
-        SLOGE("Unable to write to ums lunfile (%s)", strerror(errno));
-        close(fd);
-        return -1;
-    }
-
-    close(fd);
-    v->handleVolumeUnshared();
     if (--mUmsSharingCount == 0 && mSavedDirtyRatio != -1) {
         FILE* fp;
         if ((fp = fopen("/proc/sys/vm/dirty_ratio", "r+"))) {
@@ -1475,7 +1456,14 @@ bool VolumeManager::isMountpointMounted(const char *mp)
 }
 
 int VolumeManager::cleanupAsec(Volume *v, bool force) {
-    int rc = unmountAllAsecsInDir(Volume::SEC_ASECDIR_EXT);
+
+   
+    /* Only EXTERNAL_STORAGE needs ASEC cleanup. */
+    const char *externalPath = getenv("EXTERNAL_STORAGE") ?: "/mnt/sdcard";
+    if (0 != strcmp(v->getMountpoint(), externalPath))
+        return 0;
+
+	  int rc = unmountAllAsecsInDir(Volume::SEC_ASECDIR_EXT);
 
     AsecIdCollection toUnmount;
     // Find the remaining OBB files that are on external storage.
diff --git a/VolumeManager.h b/VolumeManager.h
index 198b5a9..07af83b 100644
--- a/VolumeManager.h
+++ b/VolumeManager.h
@@ -66,6 +66,7 @@ private:
     int                    mSavedDirtyRatio;
     int                    mUmsDirtyRatio;
     int                    mVolManagerDisabled;
+    int                    mlun;
 
 public:
     virtual ~VolumeManager();
